cmake_policy(SET CMP0054 NEW)
if(BUILDDIR)
    set(builddir ${BUILDDIR})
else()
    set(builddir ${CMAKE_CURRENT_LIST_DIR}/build)
endif()

set(dirstxt ${builddir}/dirs.txt)
file(STRINGS ${dirstxt} lis)

# Instantiate directory prefixes
#  => _localbuild == builddir (but normalized)
set(mapprefixes)
foreach(e IN LISTS lis)
    if("${e}" MATCHES "([^:]*): (.*)")
        set(varname ${CMAKE_MATCH_1})
        set(val ${CMAKE_MATCH_2})
        if(DEFINED ${varname})
            list(APPEND ${varname} ${val})
        else()
            set(${varname} ${val})
            if("${CMAKE_MATCH_1}" MATCHES "^MAP_(.*)")
                list(APPEND mapprefixes ${CMAKE_MATCH_1})
            endif()
        endif()
    elseif(e)
        message(FATAL_ERROR "Unknown line: ${e}")
    endif()
endforeach()
list(REVERSE mapprefixes)

set(hdrlisttxt ${_localbuild}/hdrlist.txt)
file(STRINGS ${hdrlisttxt} hdr_prio)

# Collect files on the paths
set(total)
foreach(prefix IN LISTS _CPATH _CXXPATH)
    file(GLOB_RECURSE files LIST_DIRECTORIES false
        ${prefix}/* ${prefix}/*.*)
    foreach(e IN LISTS files)
        if(NOT file_${e})
            list(APPEND total ${e})
            #message(STATUS "FILE: ${e}")
            set(file_${e} UNUSED)
        endif()
    endforeach()
endforeach()

set(index ${_localbuild}/index.txt)
file(STRINGS ${index} lis)

message(STATUS "Collect results...")

set(grps)
foreach(e IN LISTS lis)
    # Read index file
    #   sym CPATH CXXPATH group
    #       CPATH/CXXPATH can be "NOT_FOUND"
    if("${e}" MATCHES "([^\t]*)\t([^\t]*)\t([^\t]*)\t(.*)")
        set(sym ${CMAKE_MATCH_1})
        set(cpath ${CMAKE_MATCH_2})
        set(cxxpath ${CMAKE_MATCH_3})
        set(fgrps ${CMAKE_MATCH_4})
        if("${cpath}" STREQUAL "NOT_FOUND")
            set(cpath)
        endif()
        if("${cxxpath}" STREQUAL "NOT_FOUND")
            set(cxxpath)
        endif()
        # Prefer CPATH
        if(cpath)
            set(mypath "${cpath}")
        else()
            set(mypath "${cxxpath}")
        endif()

        # Add to group
        foreach(grp IN LISTS fgrps)
            if(grp_${grp})
                list(APPEND grp_${grp} ${sym})
            else()
                set(grp_${grp} ${sym})
                list(APPEND grps ${grp})
            endif()
        endforeach()

        # Expand path
        if("${mypath}" MATCHES "([^:]*):(.*)")
            set(g ${CMAKE_MATCH_1})
            set(f ${CMAKE_MATCH_2})
            if(MAP_${g})
                set(path_${sym} "${MAP_${g}}${f}")
                #message(STATUS "MAP: ${sym} => ${path_${sym}}")
                if(NOT file_${path_${sym}})
                    message(FATAL_ERROR "File [${mypath}] is not on GLOB list")
                endif()
            else()
                message(FATAL_ERROR "Unknown group [${mypath}]")
            endif()
        elseif(NOT mypath)
            # Skip
        else()
            message(FATAL_ERROR "Unrecognized path format [${mypath}]")
        endif()

        # message(STATUS "sym: ${sym}")
        # Select depfile
        foreach(lang c cxx)
            # deps are normalized in flitpdes.cmake
            set(depfile  ${_localbuild}/check/${sym}.${lang}.d)
            if(EXISTS ${depfile})
                file(STRINGS ${depfile} deps)
                set(deps_${sym})
                foreach(d IN LISTS deps)
                    if(d) # Skip empty line
                        cmake_path(GET d FILENAME dfn)
                        if("${dfn}" MATCHES "^cdummy")
                            continue()
                        endif()
                        if("${dfn}" MATCHES "^cxxdummy")
                            continue()
                        endif()
                        list(APPEND deps_${sym} ${d})
                        if(file_${d})
                            set(file_${d} ${sym})
                        else()
                            message(STATUS "WARN: [${d}] in ${depfile} is not on GLOB list")
                            list(APPEND total ${d})
                            set(file_${d} ${sym})
                        endif()
                    endif()
                endforeach()
            endif()
        endforeach()
    elseif(e)
        message(FATAL_ERROR "Unknown index line: ${e}")
    endif()
endforeach()

# Merge corelibs into CORELIB
set(corelibs C17 CXX POSIX_I5 POSIX_I6 POSIX_I7 POSIX_I8)
list(REMOVE_ITEM grps ${corelibs})
set(grp_CORELIB)
foreach(l IN LISTS corelibs)
    list(APPEND grp_CORELIB ${grp_${l}})
endforeach()

# Clean up group entries
foreach(grp IN LISTS grps)
    list(REMOVE_DUPLICATES grp_${grp})
    list(SORT grp_${grp})
endforeach()

message(STATUS "Reducing headers...")

function(calcprefix out base path)
    string(LENGTH ${base} baselen)
    string(LENGTH ${path} pathlen)
    if("${baselen}" GREATER "${pathlen}")
        unset(${out} PARENT_SCOPE)
        return()
    endif()
    string(SUBSTRING "${path}" 0 ${baselen} dir)
    string(SUBSTRING "${path}" ${baselen} -1 file)
    if("${dir}" STREQUAL "${base}")
        set(${out} "${file}" PARENT_SCOPE)
    else()
        unset(${out} PARENT_SCOPE)
    endif()
endfunction()

macro(shortenpath out path)
    foreach(pfx IN LISTS mapprefixes)
        calcprefix(${out} ${MAP_${pfx}} ${path})
        if(${out})
            set(${out} ${pfx}:${${out}})
            break()
        endif()
    endforeach()
    if(NOT ${out})
        message(FATAL_ERROR "Could not map back ${path}")
    endif()
endmacro()

function(genfrag out_direct out_indirect var_seen grp)
    # Reset and preload seen
    foreach(f IN LISTS ${var_seen})
        set(seen_${f} ON)
    endforeach()

    set(direct)
    set(indirect)

    # Pass1: Direct dependencies
    foreach(sym IN LISTS grp_${grp})
        set(pth ${path_${sym}})
        if(pth)
            shortenpath(tmp ${pth})
            list(APPEND direct ${tmp})
            set(seen_${tmp} ON)
        else()
            message(STATUS "Not found: ${sym}")
        endif()
    endforeach()

    # Pass2: Indirect dependencies
    foreach(sym IN LISTS grp_${grp})
        foreach(d IN LISTS deps_${sym})
            shortenpath(tmp ${d})
            if(NOT seen_${tmp})
                set(seen_${tmp} ON)
                list(APPEND indirect ${tmp})
            endif()
        endforeach()
    endforeach()

    list(REMOVE_DUPLICATES direct)
    list(SORT direct)
    list(REMOVE_DUPLICATES indirect)
    list(SORT indirect)

    set(${out_direct} ${direct} PARENT_SCOPE)
    set(${out_indirect} ${indirect} PARENT_SCOPE)
endfunction()

set(seen)
genfrag(direct0 indirect0 seen CORELIB)
list(APPEND seen ${direct0})
list(APPEND seen ${indirect0})

# Pass1: Split grps
foreach(g IN LISTS grps)
    genfrag(direct_${g} indirect_${g} seen ${g})
endforeach()

# Pass2: Priority assignment
foreach(g IN LISTS hdr_prio) # Pass2.1: Assign explicits
    foreach(i IN LISTS direct_${g})
        if(NOT prio_${i})
            set(prio_${i} ${g})
        else()
            message(STATUS "WARN: Unresolvable export [${i}][${prio_${i}}]")
        endif()
    endforeach()
endforeach()
foreach(g IN LISTS hdr_prio) # Pass2.2: Assign implicits
    foreach(i IN LISTS indirect_${g})
        if(NOT prio_${i})
            set(prio_${i} ${g})
        endif()
    endforeach()
endforeach()

foreach(g IN LISTS grps) # Pass2.3: Filter
    set(real_direct_${g})
    set(removed_direct_${g})
    set(real_indirect_${g})
    set(removed_indirect_${g})
    set(deps_${g})
    foreach(i IN LISTS direct_${g})
        if("${prio_${i}}" STREQUAL "${g}")
            list(APPEND real_direct_${g} ${i})
        else()
            list(APPEND removed_direct_${g} ${i})
            list(APPEND deps_${g} ${prio_${i}})
        endif()
    endforeach()
    foreach(i IN LISTS indirect_${g})
        if("${prio_${i}}" STREQUAL "${g}")
            list(APPEND real_indirect_${g} ${i})
        else()
            list(APPEND removed_indirect_${g} ${i})
            list(APPEND deps_${g} ${prio_${i}})
        endif()
    endforeach()

    list(REMOVE_DUPLICATES deps_${g})
    list(SORT deps_${g})
endforeach()

# Pass3: Output
function(dump grp)
    message(STATUS "GRP: ${grp}")
    foreach(d IN LISTS deps_${grp})
        message(STATUS " DEP:  ${d}")
    endforeach()
    foreach(p IN LISTS real_direct_${grp})
        message(STATUS " ${p}")
    endforeach()
    foreach(p IN LISTS real_indirect_${grp})
        message(STATUS "   ${p}")
    endforeach()
    foreach(p IN LISTS removed_direct_${grp})
        set(ref ${prio_${p}})
        message(STATUS "   ___ ${p} (${ref})")
    endforeach()
    foreach(p IN LISTS removed_indirect_${grp})
        set(ref ${prio_${p}})
        message(STATUS "   ___   ${p} (${ref})")
    endforeach()
    foreach(p IN LISTS removed_indirect_${grp})
    endforeach()
    message(STATUS "")
endfunction()

# Inject corelib result
set(real_direct_CORELIB ${direct0})
set(real_indirect_CORELIB ${indirect0})

dump(CORELIB)
foreach(g IN LISTS grps)
    dump(${g})
endforeach()

foreach(g CORELIB ${grps})
    set(grpfile ${_localbuild}/pkgs_hdr/${g}.txt)
    set(acc)
    foreach(d IN LISTS deps_${g})
        set(acc "${acc}DEP:${d}\n")
    endforeach()
    foreach(p IN LISTS real_direct_${g} real_indirect_${g})
        set(acc "${acc}${p}\n")
    endforeach()
    file(WRITE ${grpfile} "${acc}")
endforeach()
